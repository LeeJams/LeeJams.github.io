---
layout: post
title: "[프로그래머스] 롤케이크 자르기 - JavaScript"
tags: [JAVASCRIPT, PROGRAMMERS, LV2]
category: ['프로그래머스']
---

##### 문제 출처

[Lv.2 롤케이크 자르기 - JavaScript](https://school.programmers.co.kr/learn/courses/30/lessons/132265?language=javascript){:target="\_blank"}

##### 문제 설명

철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 **롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류**에 더 관심이 많습니다. 그래서 **잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.**

예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 **네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다.** 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.

롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 topping이 매개변수로 주어질 때, **롤케이크를 공평하게 자르는 방법의 수를 return** 하도록 solution 함수를 완성해주세요.

##### 제한 조건

- 1 ≤ topping의 길이 ≤ 1,000,000
  - 1 ≤ topping의 원소 ≤ 10,000

##### 예시

입출력 예

| topping                  | return |
| ------------------------ | ------ |
| [1, 2, 1, 3, 1, 4, 1, 2] | 2      |
| [1, 2, 3, 1, 4]          | 0      |

##### 풀이

```javascript
function solution(topping) {
  let answer = 0;

  const allTopping = new Map();
  const bro = new Map();

  // Map 자료구조에 각 토핑의 개수가 몇개인지 넣어준다.
  // {1 => 4, 2 => 2, 3 => 1, 4 => 1}
  topping.forEach((n) => {
    allTopping.set(n, (allTopping.get(n) || 0) + 1);
  });

  for (let n of topping) {
    // 토핑을 하나씩 확인하면서 (케익을 1부터 자르는 것)
    // allTopping의 목록을 하나씩 빼준다.
    allTopping.set(n, allTopping.get(n) - 1);

    // bro에는 토핑의 갯수가 중요하지 않고,
    // 토핑의 종류가 중요하므로 들어온 토핑의 종류 n과 true를 넣어준다.
    bro.set(n, true);

    // allTopping의 토핑이 0이되면 그 토핑 항목을 지워준다.
    if (!allTopping.get(n)) allTopping.delete(n);

    // allTopping의 크기와 bro의 크기가 같으면
    // 형과 동생이 같은 종류의 토핑을 들고있는 것이기에
    // answer을 1 증가시켜준다.
    if (allTopping.size === bro.size) answer++;

    // 동생의 가진 토핑 종류가 많아지면 더 이상 케익을
    // 잘라도 동생의 토핑 개수만 증가하는 것이기 때문에
    // break문을 걸어 반복문을 종료시킨다.
    if (allTopping.size < bro.size) break;
  }

  return answer;
}

console.log(solution([1, 2, 1, 3, 1, 4, 1, 2])); // 2
console.log(solution([1, 2, 3, 1, 4])); // 0
```

##### 정리

객체를 이요하여 문제를 풀려고 했지만 시간초과... Map 자료구조로 언능 바꿔 풀어서 성공했습니다!<br/>

피드백은 언제나 환영입니다. 😊
